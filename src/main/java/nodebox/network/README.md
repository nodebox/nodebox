# WebSocket Integration


## System Components
There are three main types of communication between Nodebox and a server:
- Data: denotes Node based communications. ie Data to/from Nodes in a graph.  For example the SocketSendData Node always sends it's packages as Data.  Every time "Data" is sent from a node it waits for data to be sent back with the same UUID.  The calling node will block for a specified time waiting for a return message.
- Command: are application commands such as play, stop, go to frame etc.  The are sent from the server to NodeBox.  Commands do not return values.
- Request/Response: requests the server can make to get information from the NodeBox document such as the current frame, file name etc.

There is a fourth type: Relay, but this is only used on the server side and should never be sent to Nodebox so can be safely ignored unless you're created a complex system.


## Data Message Structure 
The same structure is used for outgoing and incoming messages from NodeBox nodes.  If using the SocketSendData node, "msg" is the input JSON object.
The underlying system creates this structure:
```
 {
    type:"data",
    id: <Random UUID as string (generated by system, must be passed back to NodeBox)>,
    msg: [
        {key: <Value Object>},
        ...
    ]
 }
```


## Command Message Structure

The underlying system creates this structure:
```
 {
    type:"cmd",
    id: <Command Name>,
    msg: [
        {key: <Value Object>},
        ...
    ]
 }
```

Currently supported Commands, some Commands require extra data in the msg object: 
- play
- stop 
- rewind 
- setframe : msg Data:
```
    {frameNumber:<Int>}
```
- reload 
- load 
- exportrange 
```
    {fileName:<String>, exportPath:<String>, start:<Int>, end:<Int>, format<String: "PDF", "PNG", or "SVG"> }
```

Here's an example exportrange Command:
```
 {
    type:"cmd",
    id:"exportrange",
    msg:{
        exportPath: "C:/temp/export",
        fileName: "testExport",
        start: 10,
        end: 20,
        format: "svg"
        }
    ]
 }
```

## Request/Response Message Structure

The underlying system creates this structure:
```
 {
    type:"req" or "rsp",
    id: <Request Name>,
    msg: [
        {key: <Value Object>},
        ...
    ]
 }
```

Currently supported Requests and Responses, some Commands require extra data in the msg object: 
- getframe: Get the current animation frame number.  Response Message:
```
    {frameNumber: <Int>}
```
- getdoc:  Get's information about the current document.  Response Message:
```
    {id: <String UUID>, fileName: <String>}
```
- getdocs: Get's information about all currently open documents.  Response Message:
```
    [{id: <String UUID>, fileName: <String>},
    ...
    ]
```

## Graph Nodes
####SocketSendData 
This is the main node in the WinSockets implementation.  It takes a JSON string as input which becomes the value of the msg property.  This node will block execution in the graph until a response is received or the TimeOut value is reached.

####GeometryToJson 
This node takes any Geometry as input and converts it to a JSON string.  This way you can send geometry to a server for processing.

####CookGraph 
This takes Geometry and object as inputs.  The output is a pass through of the input Geometry however it forces the valuation of the object input.  This way you can send data to a server while keeping the Geometry visible.


## Development Nodes
Here's the basic additions and how it works: 
1. I've added a new entry in Preferences to enable/disable websockets and the server address.

2. When Nodebox starts it creates a static websocket connection that can be accessed from graph nodes. I've added several node type: 
Network -> SocketSendData 
This is similar to HTTP Get but using the websocket interface. It's input is a JSON string. It sends it's input string to the server and then waits for a response which is the node's outputs as JSON. This works by assigning a unique ID to each request, then the node blocks until a response with a matching ID is found to ensure node cooking order is maintained (lots of threading moving parts here). You can then use the exiting query json node to get at the received data. 
Network(?) -> GeometryToJson 
This takes any geometry/shapes/paths etc as input and encodes it to JSON. This can be used to send geometry information to the server for processing. TODO: Build a JsonToGeometry node. 
Network(?) -> CookGraph 
This node allows you to cook part of a graph while still outputting geometry. This can be used to force the system to send data to the server while still flowing the geometry through the graph.

3. Each open document has a command websocket used to send commands and requests. 
Current list of commands: 
PLAY 
STOP 
REWIND 
SETFRAME 
RELOAD 
LOAD 
EXPORTRANGE 
List of requests: 
GETFRAME – Returns the current frame number 
GETDOCS – Returns an array of all open documents 
GETDOC – Returns info about the current document

4. I’ve created a test server in Python. It would be pretty easy to implement a server in node.js or any other framework/language you like. 
5. Server supports relay commands, this way you can have a control client which can send data to Nodebox. This is more for test purposes right now but could easily be turned into something more useful. Currently it just broadcasts commands to all open documents.